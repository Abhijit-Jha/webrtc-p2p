//gcloud artifacts docker images list asia-east1-docker.pkg.dev/dhrona-415109/cloud-run-source-deploy

import fs from 'fs-extra';
import path from 'path';
import sharp from 'sharp';
import { logger } from '../../../common/logger';
import { publicPath } from '../../../common/commonConstants';
import { imgGenApi_HF, imgGenApi } from '../promptAI/imgGen';
import { limitAndSanitize, parseAITool } from './aiUtils';;

export async function saveImg({ imgData, imgPath, curriculumId }) {
    try {
    imgPath = `${publicPath}${imgPath}`;
    const outputPath = imgPath.endsWith('.webp') ? imgPath : `${imgPath}.webp`;

    const directory = path.dirname(outputPath);
    if (!fs.existsSync(directory)) {
      fs.mkdirSync(directory, { recursive: true });
    }

    logger({
      level: 'log',
      save: ['db'],
      parent: curriculumId,
      msg: `imgData:`,
      data: `${imgData.substring(0, 10)}...`,
    });

    const buffer = Buffer.from(imgData, 'base64');

    await sharp(buffer)
      .toFormat('webp')
      .toFile(outputPath)
      .then(() => {
        logger({
          level: 'info',
          save: ['db'],
          parent: curriculumId,
          msg: "Image saved to ${outputPath}",
          data: '',
        });

        if (fs.existsSync(outputPath)) {
          const stats = fs.statSync(outputPath);
          if (stats.size > 0) {
            logger({
              level: 'info',
              save: ['db'],
              parent: curriculumId,
              msg: "File size: ${stats.size} bytes",
              data: '',
            });
          } else {
            logger({
              level: 'error',
              save: ['db'],
              parent: curriculumId,
              msg: `Error: Image file was created, but it's empty.`,
              data: '',
            });
          }
        } else {
          logger({
            level: 'error',
            save: ['db'],
            parent: curriculumId,
            msg: `Error: Image file was not created.`,
            data: '',
          });
        }
      })
      .catch((err) => {
        logger({
          level: 'error',
          save: ['db'],
          parent: curriculumId,
          msg: `Error saving image to ${outputPath}: ${err}`,
          data: '',
        });
      });
  } catch (error) {
    logger({
      level: 'error',
      save: ['db'],
      parent: curriculumId,
      msg: `Error processing image data: ${error}`,
      data: '',
    });
  }
}

export async function generateAndSaveImg(
    {
        vendor = 'OPEN_AI',
        imgPromptTxt,
        model = 'dall-e-3',
        imgPath,
        curriculumId,
        isInBatch = false //If batch, then all the details would be stored and the AI api calls would be made in batch
      }: {
        vendor?: string;
        imgPromptTxt: string;
        model?: string;
        imgPath: string;
        curriculumId: any;
        isInBatch: boolean;
      }

) {
  let imgData: string | undefined | void = '';

  if (vendor === 'HUGGING_FACE') {
    const modelParts = model.split(':');
    if (modelParts.length !== 2) {
      return console.error(
        `generateAndSaveImg(): imgGenerateAiTool property expected in the format "HUGGING_FACE/vendor:model" for hugging face, received: ${model}`
      );
    }

    vendor = modelParts[0];
    model = modelParts[1];

    imgData =
      (await imgGenApi_HF({
        vendor,
        model,
        textPrompt: imgPromptTxt,
        isMock: false,
      })) || undefined;
  } else {
    // Placeholder for actual image generation logic using the imgGenApi
    imgData = await imgGenApi({
      vendor,
      textPrompt: imgPromptTxt,
      model,
      imgsNo: 1,
      size: '1024x1024',
      quality: 'hd',
      response_format: 'b64_json',
    });
  }

  logger({
    level: 'info',
    save: ['db'],
    parent: curriculumId,
    msg: "generateAndSaveImg",
    data: `${imgData?.substring(0, 10)}...`,
  });
  //UT
  imgData && (await saveImg({ imgData, imgPath, curriculumId }));
}
// Add these functions to the existing file

// Function to get image prompt content
export function getImgCreationDetails(
  data: any,
  skillNameUpdated: string,
  curriculumId: string,
  getSubTopicFromPromptText: () => string,
  mlConstants: any
) {
  console.info(`In getImgCreationDetails, checking data:, data`);

  for (const item of data) {
    if (item.element.includes('imgPrompt')) {
      const { content: imgPromptTxt, subDirName } = item,
        imgName = `${subDirName}_${limitAndSanitize(
          getSubTopicFromPromptText()
        )}`;

      item.imgPath = `${mlConstants.mlAssetsPath}${skillNameUpdated}/${subDirName}/${imgName}`;

      logger({
        level: 'info',
        save: ['db'],
        parent: curriculumId,
        msg: `getImgCreationDetails`,
        data: { imgPromptTxt },
      });
      return [imgPromptTxt, item.imgPath];
    }
  }
  return [null, null];
}

export async function handleImgCreation({
  imgGenerateAiTool,
  resp,
  promptsObj,
  promptKey,
  skillNameUpdated,
  curriculumId,
  getSubTopicFromPromptText,
  mlConstants,
}) {
  if (imgGenerateAiTool) {
    console.info(`In imgGenerateAiTool, checking resp:, resp`);
    const [imgPromptTxt, imgPath] = getImgCreationDetails(
      resp[0].render,
      skillNameUpdated,
      curriculumId,
      getSubTopicFromPromptText,
      mlConstants
    );

    if (!imgPromptTxt) {
      return;
    }

    const { vendor, model } = parseAITool(imgGenerateAiTool);
    await generateAndSaveImg({
        vendor,
        imgPromptTxt,
        model,
        imgPath,
        curriculumId,
        isInBatch: false
      });
  }
}